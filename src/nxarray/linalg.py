from sys import maxsize
from typing import Tuple, Hashable, Callable, Any, TypeVar, Optional
from functools import reduce, partial
from numpy import reshape, newaxis, sum, cumsum, sqrt
from numpy.typing import NDArray
from numpy.linalg import qr as npqr, svd as npsvd
from nxarray.core import NXArray

T = TypeVar("T")


def _split(
    something: Tuple[T, ...], pos: int
) -> Tuple[Tuple[T, ...], Tuple[T, ...]]:
    assert pos >= 0, pos
    assert len(something) >= pos, pos
    return something[:pos], something[pos:]


def _release_normalized_reshaped_array(
    nxarr: NXArray, shape: Tuple[int, ...]
) -> NDArray:
    return reshape(nxarr.release_normalized_array(*nxarr.index_ids), shape)


def _decompose(
    split_nxarray: Tuple[int, NXArray],
    func: Callable[[NDArray], Tuple[NDArray, NDArray]],
    new_index_id: Hashable,
) -> Tuple[NXArray, NXArray]:
    pos, nxarr = split_nxarray
    log_norm = nxarr.log_norm
    left_shape, right_shape = _split(nxarr.shape, pos)
    left_indices, right_indices = _split(nxarr.index_ids, pos)
    if new_index_id in left_indices or new_index_id in right_indices:
        raise ValueError(
            f'ID of a new index "{new_index_id}" induced by a decomposition is already presend among IDs of the decomposed array.'
        )
    left_dim = reduce(lambda x, y: x * y, left_shape)
    arr = _release_normalized_reshaped_array(nxarr, (left_dim, -1))
    left_arr, right_arr = func(arr)
    left_arr = reshape(left_arr, (*left_shape, -1))
    right_arr = reshape(right_arr, (-1, *right_shape))
    left_nxarr = NXArray(left_arr, *left_indices, new_index_id)
    right_nxarr = NXArray(right_arr, new_index_id, *right_indices)
    right_nxarr._log_norm += log_norm
    return left_nxarr, right_nxarr


"""Performs QR decomosition of an array with respect to a fixed splitting.

Args:
    split_nxarray: an array with the fixed splitting (see __getitem__ of NXArray method to see how
        to fix splitting);
    new_index_id: name of the axis which is generated by the decomposition.

Returns: Q and R as two NXArrays.

Raises:
    ValueError: raises when the `new_index_id` ID is already present in the decomposed array;
    LinearAlgebraError: raises when the factoring fails.
"""


def qr(
    split_nxarray: Tuple[int, NXArray], new_index_id: Hashable
) -> Tuple[NXArray, NXArray]:
    return _decompose(split_nxarray, npqr, new_index_id)


def _find_rank_for_eps(s: NDArray, eps: float) -> int:
    assert len(s.shape) == 1
    full_rank = s.shape[0]
    s_sq = s**2
    return full_rank - sum(sqrt(cumsum(s_sq[::-1]) / sum(s_sq)) < eps)


def _svd_with_truncation(
    truncation_func: Callable[
        [NDArray, NDArray, NDArray], Tuple[NDArray, NDArray]
    ],
    m: NDArray,
) -> Tuple[NDArray, NDArray]:
    u, s, vh = npsvd(m, full_matrices=False)
    return truncation_func(u, s, vh)


def _truncate_by_rank(
    rank: int, u: NDArray, s: NDArray, vh: NDArray
) -> Tuple[NDArray, NDArray]:
    assert len(u.shape) == 2
    assert len(vh.shape) == 2
    assert len(s.shape) == 1
    rank = min(rank, s.shape[0])
    u = u[:, :rank]
    s = s[:rank]
    vh = vh[:rank]
    return u, s[:, newaxis] * vh


def _truncate_by_error(
    eps: float, u: NDArray, s: NDArray, vh: NDArray
) -> Tuple[NDArray, NDArray]:
    rank = _find_rank_for_eps(s, eps)
    return _truncate_by_rank(rank, u, s, vh)


def _truncate_by_error_and_rank(
    eps: float, rank: int, u: NDArray, s: NDArray, vh: NDArray
) -> Tuple[NDArray, NDArray]:
    rank = min(rank, _find_rank_for_eps(s, eps))
    return _truncate_by_rank(rank, u, s, vh)


"""Performs SVD decomosition of an array with respect to a fixed splitting (in contrast with
    standart API, it returns a pair `(u, s * vh)` instead of a three-element tuple `(u, s, v)`).

Args:
    split_nxarray: an array with the fixed splitting (see __getitem__ method of NXArray to see how
        to fix splitting);
    new_index_id: name of the axis which is generated by the decomposition;
    rank_threshold: optional truncation rank of the final result;
    error_threshold: optional maximal truncation error of the final result;
    

Returns: U and S * Vh as two NXArrays.

Raises:
    ValueError: raises when the `new_index_id` ID is already present in the decomposed array;
    LinearAlgebraError: raises when the factoring fails.
"""


def svd(
    split_nxarray: Tuple[int, NXArray],
    new_index_id: Hashable,
    rank_threshold: Optional[int] = None,
    error_threshold: Optional[float] = None,
) -> Tuple[NXArray, NXArray]:
    if rank_threshold and error_threshold:
        decomposition_func = partial(
            _svd_with_truncation,
            partial(
                _truncate_by_error_and_rank, error_threshold, rank_threshold
            ),
        )
    elif error_threshold:
        decomposition_func = partial(
            _svd_with_truncation, partial(_truncate_by_error, error_threshold)
        )
    elif rank_threshold:
        decomposition_func = partial(
            _svd_with_truncation, partial(_truncate_by_rank, rank_threshold)
        )
    else:
        decomposition_func = partial(
            _svd_with_truncation, partial(_truncate_by_rank, maxsize)
        )
    return _decompose(
        split_nxarray,
        decomposition_func,
        new_index_id,
    )
